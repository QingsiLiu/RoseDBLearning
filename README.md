# RoseDBLearning——RoseDB学习记录

## Redis学习笔记

### 1.为什么要使用SDS而不是C string（好处）
* ①能够在常数复杂度获取字符串的长度
* ②防止缓冲区溢出
* ③减少修改字符串时带来的内存重新分配次数(空间预分配以及惰性空间释放两种优化策略)
   * 空间预分配：小于1MB的时候每次扩展一倍，大于1MB每次多申请1MB的内存地址空间
   * 惰性空间释放：需要缩短SDS保存的字符串时，使用free属性将字节数量记录起来，并不是直接释放掉了内存地址空间
* ④二进制安全，Redis不是用buf数组来保存字符，而是用它来保存一系列没要限制的二进制数据
* ⑤兼容部分C字符串函数

### 2.Redis中的链表结构
* 双向链表listNode
* 链表list结构：haed、tail、len、dup、free、match
* 由list结构和listNode组成链表结构

### 3.Redis中的链表特性
* ①双端：双向链表节点
* ②无环
* ③具有表头指针和表尾指针
* ④具有链表长度计数器
* ⑤多态：链表节点通过void指针来保存节点值，并且可以通过dup、free、match三个属性为节点值设置特定类型函数，故链表可以用于保存各种不同的值

### 4.Redis中的字典
* 使用哈希表作为底层实现，一个哈希表中可以有多个哈希表节点，每个哈希表节点保存一个键值对
* 哈希表（dictht）：table、size、sizemask、used
   * table是一个数组，每个元素指向一个dictEntry，每个entry结构保存着一个键值对
   * size记录了哈希表的大小，也就是table数组大小
   * used鸡柳已有键值对的数量
   * sizemask总是等于size-1，和哈希值一起决定键的索引位置
 * 哈希表节点（dictentry）：key、val、\*next（将多个哈希值相同的键值对链接在一起，以解决键冲突的问题）
 * 字典（dict）：dictType（特定类型）、privdata（私有数据）、dictht（哈希表）、rehash索引：
    * type属性是一个指向dictType结构的指针，为不同的字典设置不同的类型特定函数
    * privdata保存了需要传给哪些类型特定函数的可选参数
    * ht包含两个项的数组，每个项都是一个dictht哈希表

### 5.哈希算法
* 根绝键值对的键值计算出哈希值和索引值，再根据索引值将键值对放在指定索引上：
   * hash=dict->type->hashFunction（key）
   * index = hash & dict -> ht[x].sizemask

### 6.解决键冲突
* Redis哈希表使用链地址法来解决键冲突
* 为了速度考虑，程序总是将新节点添加到链表的表头位置，拍在已有节点的前面

### 7.rehash
* 为了让负载因子维持在一个合理的范围，当保存的键值对数量太多或太少时，需要对哈希表的大小进行扩展或者收缩
   * 扩展操作：ht[1]的大小为第一个大于等于ht[0].used/*2的2的n次方幂
   * 收缩操作：ht[1]的代销为第一个大于等于ht[0].used的2的n次方幂
* ht[0]--->ht[1]
* 迁移结束后释放ht[0]，将ht1设置为ht0，并在ht1创建一个新的空白哈希表

### 8.跳跃表
* 由zskiplistNode和zskiplist两个结构定义
* zskiplist：
   * header：指向跳表头结点
   * tail：指向跳表尾结点
   * length：跳表的长度，跳表目前包含节点的数量，不计表头节点
   * level：层数最大的节点的层数
* zskiplistNode：
   * level：层数
   * 后退指针：指向前置指针
   * 分值：按各自所保存的分值有小到大排列
   * 成员对象

### 9.整数集合
* 用于保存整数值的集合抽象数据类型，可以保存类型为int16_t、int32_t、int64_t的无重复整数值
* intset表示一个整数集合：
   * encoding 编码方式
   * length  包含的元素数量
   * contents[]  保存元素的数组，数据类型取决于encoding的类型

### 10.升级整数集合并添加新元素的过程为
* 根据新元素的类型扩展整数集合底层数组的空间大小，并分配新的地址空间
* 将所有现有元素转换为新元素的类型，并将元素放置到正确位置上，保持有序
* 将新元素添加到底层数组里面
* 新元素小于当、前所有元素，放在最开头（索引为0）；新元素大于当前所有元素，放在末尾（索引为length-1）

### 11.整数集合的升级过程优点
* 好处：提升整数集合的灵活性、尽可能地节约内存
   * 灵活性：不用担心出现类型错误
   * 节约内存： 在需要的时候进行升级操作，尽可能的节省内存

### 12.整数集合不支持降级操作
* 即使删除了一个类型的数据，仍然不会改变整个整数集合的数据类型

### 13.压缩列表的适用场景
* 当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度较短的字符串，那么就会适用压缩列表来做列表键的底层实现

### 14.压缩列表的构成
* 一个压缩列表可以包含多个节点（entry），每个节点可以保存一个字节数组或者一个整数值
* zlbytes:记录正用的内存字节数
* zltail:记录表尾节点距离压缩列表的起始地址有多少个字节，便于确定确定表尾
* zllen:记录了压缩列表的节点数量，小于UINT16_MAX时就是节点数量，等于的时候要逐个遍历
* entryX:压缩列表的各个节点
* zlend:用于标记压缩列表的末端

### 15.压缩列表的节点构成
* previous_entry_length：记录前一节点的长度，如果小于254字节，那么长度为1字节，大于等于的时候则为5个字节
* encoding：记录了节点的content属性所保存数据的类型以及长度
* content：负责保存节点的值，类型和长度由encoding决定

### 16.Redis中的对象：类型与编码
* 新创建一个键值对时，至少会创建两个对思想，一个用作键值对的键，一个用作键值对的值
* 每个对象有一个residsObject结构表示：type、encoding、ptr（指向底层数据结构的指针）
* 类型type：键总是一个字符串，而值可以是字符串对象、列表对象、哈希集合有序集合对象

### 17.使用embstr编码字符串来保存段字符串值的好处
* embstr编码将创建字符串对象所需的内存分配冲raw编码的两次降低为一次
* 释放embstr编码的字符串对象只需要调用一次内存释放函数，raw需要两次
* embstr编码的字符串能保存在一块连续的内存中，能更好的利用缓存带来的优势

### 18.字符串对象编码类型
* int、embstr、raw（SDS）

### 19.对于long double类型
* 同样是作为字符串值来保存的
* 如果有浮点数加减等操作，会先转换为浮点数，操作完后再转化为字符串类型

### 20.关于编码的转换
* 例如int编码的字符串对象和embstr字符串在条件满足的情况下，会被转换为raw编码的字符串对象
* 由于embstr编码类型是只可读类型，对embstr编码的字符串执行任何修改命令后，会从embstr类型转换成raw，然后再执行修改命令，所以embstr修改之后就会转换为raw类型

### 21.列表对象的编码类型
* ziplist或者linkedlist

### 22.列表对象的编码转换
* 什么时候会用ziplist压缩链表呢（否则要使用linkedlist编码）（不满足条件的时候会转换为linkedlist）：
   * 列表对象保存的所有字符串长度都小于64字节
   * 列表对象保存的元素数量小于512个
   * 以上的两个上限值都可以进行修改

### 23.哈希对象的编码方式
* ziplist和hashtable

### 24.哈希对象的ziplist方式：
* 先将保存了键的压缩列表节点推入到压缩列表表尾，再将保存了值的压缩列表节点推入压缩列表表尾
   * 保存了同一键值对的两个节点总是紧挨，保存键的在前，值在后
   * 先添加的在表头，后添加的在表尾

### 25.哈希对象的编码转换
* 什么时候会用ziplist压缩链表呢（否则要使用hashable编码）（不满足条件的时候会转换为hashable）：
   * 哈希对象保存的所有键值对字符串长度和小于64字节
   * 哈希对象保存的键值对数量小于512个
   * 以上的两个上限值都可以进行修改

### 26.集合对象的编码方式
* intset 或者hashtable
* intset编码的集合对象使用整数集合作为底层实现
* intset编码方式的适用场景（不满足则需要用hashtable编码方式）：
   * 集合对象保存的元素都是整数
   * 集合对象保存的元素数量不超过512个

### 27.有序集合的编码方式
* ziplist或者skiplist
* skiplist编码方式使用zset结构作为底层实现，同时包含一个字典和一个跳跃表，并且这两种数据结构都会通过指针来共享相同的元素的成员和分值，不会造成额外的内存浪费

### 28.为什么有序集合需要使用跳跃表和字典来实现
* 性能比单独使用任何一种都要强
* 只用字典来实现，那么每次都要排序，浪费性能
* 只用跳跃表来实现，但根绝成员查找分值复杂度将会上升

### 29.有序集合的编码转换
* ziplist的适用场景：
   * 有序集合保存的元素数量小于128个
   * 有序集合保存的所有元素成员长度都小于64字节 

### 30.各个类型常用命令：
* 字符串键：set、get、append、strlen
* 哈希建：hdel、hset、hget、hlen
* 列表建：rpush、lpop、linsert、llen
* 集合键：sadd、spop、sinter、scard
* 有序集合建：zadd、zcard、zrank、zscore
* 先检查输入键的类型是否正确，之后再决定是否执行给定的命令，类型检查是通过redisobject的type属性来实现的
* 多态命令的实现：根绝对象的编码方式，选择正确的命令实现代码来执行命令

### 31.Redis的内存回收机制（GC）
* 引用计数法来实现内存回收机制
 
### 32.对象共享
* 将数据库键的值指针指向一个现有的值对象
* 会共享值为0到9999的字符串对象
* 将被共享的值对象的引用计数+1
* 对于节约内存非常有帮助，保存的相同值对象越多，共享机制就能节省越多的内存
* 可以使用object refcount命令来查看值对象的引用计数
* 在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象

### 33.为什么Redis不共享包含字符串的对象
* 将一个共享对象设置为建的值对象时，需要先检查共享对象和键想创建的目标对象是否完全一致，完全一致才可以，而一个共享对象保存的值越复杂，验证是否一直过程消耗的就会很大

### 34.对象的空转时长
* Object结构包含最后一个属性为lru属性，记录了对象最后一次被命令程序访问的时间
* Object idletime命令可以打印出空转时长，通过当前时间减去键值对象的lru时间计算出来的




















