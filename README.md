# RoseDBLearning——RoseDB学习记录

## Redis学习笔记

### 1.为什么要使用SDS而不是C string（好处）
* ①能够在常数复杂度获取字符串的长度
* ②防止缓冲区溢出
* ③减少修改字符串时带来的内存重新分配次数(空间预分配以及惰性空间释放两种优化策略)
   * 空间预分配：小于1MB的时候每次扩展一倍，大于1MB每次多申请1MB的内存地址空间
   * 惰性空间释放：需要缩短SDS保存的字符串时，使用free属性将字节数量记录起来，并不是直接释放掉了内存地址空间
* ④二进制安全，Redis不是用buf数组来保存字符，而是用它来保存一系列没要限制的二进制数据
* ⑤兼容部分C字符串函数

### 2.Redis中的链表结构
* 双向链表listNode
* 链表list结构：haed、tail、len、dup、free、match
* 由list结构和listNode组成链表结构

### 3.Redis中的链表特性
* ①双端：双向链表节点
* ②无环
* ③具有表头指针和表尾指针
* ④具有链表长度计数器
* ⑤多态：链表节点通过void指针来保存节点值，并且可以通过dup、free、match三个属性为节点值设置特定类型函数，故链表可以用于保存各种不同的值

### 4.Redis中的字典
* 使用哈希表作为底层实现，一个哈希表中可以有多个哈希表节点，每个哈希表节点保存一个键值对
* 哈希表（dictht）：table、size、sizemask、used
   * table是一个数组，每个元素指向一个dictEntry，每个entry结构保存着一个键值对
   * size记录了哈希表的大小，也就是table数组大小
   * used鸡柳已有键值对的数量
   * sizemask总是等于size-1，和哈希值一起决定键的索引位置
 * 哈希表节点（dictentry）：key、val、\*next（将多个哈希值相同的键值对链接在一起，以解决键冲突的问题）
 * 字典（dict）：dictType（特定类型）、privdata（私有数据）、dictht（哈希表）、rehash索引：
    * type属性是一个指向dictType结构的指针，为不同的字典设置不同的类型特定函数
    * privdata保存了需要传给哪些类型特定函数的可选参数
    * ht包含两个项的数组，每个项都是一个dictht哈希表

### 5.哈希算法
* 根绝键值对的键值计算出哈希值和索引值，再根据索引值将键值对放在指定索引上：
   * hash=dict->type->hashFunction（key）
   * index = hash & dict -> ht[x].sizemask

### 6.解决键冲突
* Redis哈希表使用链地址法来解决键冲突
* 为了速度考虑，程序总是将新节点添加到链表的表头位置，拍在已有节点的前面

### 7.rehash
* 为了让负载因子维持在一个合理的范围，当保存的键值对数量太多或太少时，需要对哈希表的大小进行扩展或者收缩
   * 扩展操作：ht[1]的大小为第一个大于等于ht[0].used/*2的2的n次方幂
   * 收缩操作：ht[1]的代销为第一个大于等于ht[0].used的2的n次方幂
* ht[0]--->ht[1]
* 迁移结束后释放ht[0]，将ht1设置为ht0，并在ht1创建一个新的空白哈希表

### 8.跳跃表
* 由zskiplistNode和zskiplist两个结构定义
* zskiplist：
   * header：指向跳表头结点
   * tail：指向跳表尾结点
   * length：跳表的长度，跳表目前包含节点的数量，不计表头节点
   * level：层数最大的节点的层数
* zskiplistNode：
   * level：层数
   * 后退指针：指向前置指针
   * 分值：按各自所保存的分值有小到大排列
   * 成员对象

### 9.整数集合
* 用于保存整数值的集合抽象数据类型，可以保存类型为int16_t、int32_t、int64_t的无重复整数值
* intset表示一个整数集合：
   * encoding 编码方式
   * length  包含的元素数量
   * contents[]  保存元素的数组，数据类型取决于encoding的类型

### 10.升级整数集合并添加新元素的过程为
* 根据新元素的类型扩展整数集合底层数组的空间大小，并分配新的地址空间
* 将所有现有元素转换为新元素的类型，并将元素放置到正确位置上，保持有序
* 将新元素添加到底层数组里面
* 新元素小于当、前所有元素，放在最开头（索引为0）；新元素大于当前所有元素，放在末尾（索引为length-1）

### 11.整数集合的升级过程优点
* 好处：提升整数集合的灵活性、尽可能地节约内存
   * 灵活性：不用担心出现类型错误
   * 节约内存： 在需要的时候进行升级操作，尽可能的节省内存

### 12.整数集合不支持降级操作
* 即使删除了一个类型的数据，仍然不会改变整个整数集合的数据类型

### 13.压缩列表的适用场景
* 当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度较短的字符串，那么就会适用压缩列表来做列表键的底层实现

### 14.压缩列表的构成
* 一个压缩列表可以包含多个节点（entry），每个节点可以保存一个字节数组或者一个整数值
* zlbytes:记录正用的内存字节数
* zltail:记录表尾节点距离压缩列表的起始地址有多少个字节，便于确定确定表尾
* zllen:记录了压缩列表的节点数量，小于UINT16_MAX时就是节点数量，等于的时候要逐个遍历
* entryX:压缩列表的各个节点
* zlend:用于标记压缩列表的末端

### 15.压缩列表的节点构成
* previous_entry_length：记录前一节点的长度，如果小于254字节，那么长度为1字节，大于等于的时候则为5个字节
* encoding：记录了节点的content属性所保存数据的类型以及长度
* content：负责保存节点的值，类型和长度由encoding决定

### 16.Redis中的对象：类型与编码
* 新创建一个键值对时，至少会创建两个对思想，一个用作键值对的键，一个用作键值对的值
* 每个对象有一个residsObject结构表示：type、encoding、ptr（指向底层数据结构的指针）
* 类型type：键总是一个字符串，而值可以是字符串对象、列表对象、哈希集合有序集合对象

### 17.使用embstr编码字符串来保存段字符串值的好处
* embstr编码将创建字符串对象所需的内存分配冲raw编码的两次降低为一次
* 释放embstr编码的字符串对象只需要调用一次内存释放函数，raw需要两次
* embstr编码的字符串能保存在一块连续的内存中，能更好的利用缓存带来的优势

### 18.字符串对象编码类型
* int、embstr、raw（SDS）

### 19.对于long double类型
* 同样是作为字符串值来保存的
* 如果有浮点数加减等操作，会先转换为浮点数，操作完后再转化为字符串类型

### 20.关于编码的转换
* 例如int编码的字符串对象和embstr字符串在条件满足的情况下，会被转换为raw编码的字符串对象
* 由于embstr编码类型是只可读类型，对embstr编码的字符串执行任何修改命令后，会从embstr类型转换成raw，然后再执行修改命令，所以embstr修改之后就会转换为raw类型

### 21.列表对象的编码类型
* ziplist或者linkedlist

### 22.列表对象的编码转换
* 什么时候会用ziplist压缩链表呢（否则要使用linkedlist编码）（不满足条件的时候会转换为linkedlist）：
   * 列表对象保存的所有字符串长度都小于64字节
   * 列表对象保存的元素数量小于512个
   * 以上的两个上限值都可以进行修改

### 23.哈希对象的编码方式
* ziplist和hashtable

### 24.哈希对象的ziplist方式：
* 先将保存了键的压缩列表节点推入到压缩列表表尾，再将保存了值的压缩列表节点推入压缩列表表尾
   * 保存了同一键值对的两个节点总是紧挨，保存键的在前，值在后
   * 先添加的在表头，后添加的在表尾

### 25.哈希对象的编码转换
* 什么时候会用ziplist压缩链表呢（否则要使用hashable编码）（不满足条件的时候会转换为hashable）：
   * 哈希对象保存的所有键值对字符串长度和小于64字节
   * 哈希对象保存的键值对数量小于512个
   * 以上的两个上限值都可以进行修改

### 26.集合对象的编码方式
* intset 或者hashtable
* intset编码的集合对象使用整数集合作为底层实现
* intset编码方式的适用场景（不满足则需要用hashtable编码方式）：
   * 集合对象保存的元素都是整数
   * 集合对象保存的元素数量不超过512个

### 27.有序集合的编码方式
* ziplist或者skiplist
* skiplist编码方式使用zset结构作为底层实现，同时包含一个字典和一个跳跃表，并且这两种数据结构都会通过指针来共享相同的元素的成员和分值，不会造成额外的内存浪费

### 28.为什么有序集合需要使用跳跃表和字典来实现
* 性能比单独使用任何一种都要强
* 只用字典来实现，那么每次都要排序，浪费性能
* 只用跳跃表来实现，但根绝成员查找分值复杂度将会上升

### 29.有序集合的编码转换
* ziplist的适用场景：
   * 有序集合保存的元素数量小于128个
   * 有序集合保存的所有元素成员长度都小于64字节 

### 30.各个类型常用命令：
* 字符串键：set、get、append、strlen
* 哈希建：hdel、hset、hget、hlen
* 列表建：rpush、lpop、linsert、llen
* 集合键：sadd、spop、sinter、scard
* 有序集合建：zadd、zcard、zrank、zscore
* 先检查输入键的类型是否正确，之后再决定是否执行给定的命令，类型检查是通过redisobject的type属性来实现的
* 多态命令的实现：根绝对象的编码方式，选择正确的命令实现代码来执行命令

### 31.Redis的内存回收机制（GC）
* 引用计数法来实现内存回收机制
 
### 32.对象共享
* 将数据库键的值指针指向一个现有的值对象
* 会共享值为0到9999的字符串对象
* 将被共享的值对象的引用计数+1
* 对于节约内存非常有帮助，保存的相同值对象越多，共享机制就能节省越多的内存
* 可以使用object refcount命令来查看值对象的引用计数
* 在数据结构中嵌套了字符串对象的对象都可以使用这些共享对象

### 33.为什么Redis不共享包含字符串的对象
* 将一个共享对象设置为建的值对象时，需要先检查共享对象和键想创建的目标对象是否完全一致，完全一致才可以，而一个共享对象保存的值越复杂，验证是否一直过程消耗的就会很大

### 34.对象的空转时长
* Object结构包含最后一个属性为lru属性，记录了对象最后一次被命令程序访问的时间
* Object idletime命令可以打印出空转时长，通过当前时间减去键值对象的lru时间计算出来的

### 35.服务器中的数据库
* 所有数据库都保存在db数组中，每个项都是一个redisDb结构，每个结构代表一个数据库，初始化时根据服务器状态dbnum来决定创建数据库数量
* 切换数据库可以用select命令，客户端状态redisClient结构的db属性记录了当前的目标数据库，是一个指向redisDb结构的指针
* 没有显示当前数据库的命令，最好先执行一个select命令，再执行数据库操作
* 每一个redisDb结构的dict字典保存了数据库中的所有键值对，这个字典就是键空间，就是一个字典，key为键值，val为字符串、列表、哈希等

### 36.数据操作的实现原理
* 添加新键：将一个新的键值对添加到字典中，键为字符串对象，值为任意一种类型的Redis对象
* 删除键：删除键空间字典中的键值对
* 更新键：对键空间中键对应的值对象进行更新，不同类型更新的具体方法也不同
* 对键取值：从键空间中取出键对应的值对象，不同类型取值方法也不同
* 读写键空间时的维护操作：
   * 读取一个键后，要根据键是否存在来更新服务器的键空间命中次数或不命中次数
   * 读取一个键后，更新键的LRU（最后一次）使用时间、
   * 如果发现键已经过期，则会先删除这个过期的键，再执行其他操作
   * 有客户端使用watch监视某个键，修改后标记为dirty
   * 服务器每次修改一个键后，都会对dirty键计数器值增1，这个计数器会触发服务器的持久化以及复制操作
   * 对键修改后，服务器将发送响应的数据库通知
 
 ### 37.键的生存时间、过期时间
 * 使用expire或pexpire命令，可以设置生存时间，自动删除时间为0的键
 * TTL或pttl命令返回键的生存时间
 * expire、pexpire、expireat、pexpireat都由pexpireat实现
 * redisDb结构的expires字典保存了数据库中所有键的过期时间，即为过期字典：
    * 过期字典的键是一个指针，指向键空间中的某个键对象
    * 过期字典的值是一个longlong类型的整数，保存了一个毫秒精度的UNIX时间戳
 * ersist命令可以移除键的过期时间

### 38.如何判定键是否过期
* 检查键是否存在于过期字典，如果存在取得过期时间
* 检查当前UNIX时间戳是否大约键的过期时间，大于已过期

### 39.过期键的删除策略
* 定时删除：设置定时器
   * 对于内存友好，保证过期键及时删除
   * 对于CPU时间不友好，影响响应时间和吞吐量
* 惰性删除：放任过期不管，每次取键时检查，过期就删除
   * 对cpu时间最友好
   * 对内存不友好，过期键内存得不到及时释放，没有被访问的键就永远不被删除清理，类似内存泄漏
* 定期删除：每隔一段时间，检查数据库，删除过期键
   * 每个一段时间执行一次删除，限制删除时长和频率，保证性能同时减少内存浪费
   * 根据情况设置执行时长和删除频率

### 40.AOF、RDB和复制对过期键处理
* 生成RDB文件时，过期键不会生成
* 主服务器载入RDB无过期键，从服务器载入RDB文件会加载过期键
* AOF持久化模式运行是，过期键没有被删除则没有操作，如果呗删除则追加一天del命令来记录
* 复制模式下，从服务器的过期键删除有主服务器控制，从服务器只有街道主服务器的del命令才删除过期键

### 41.RDB持久化（SAVE和BGSAVE）
* 功能是将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失
* 既可以手动执行，也可以根据服务器配置选项定期执行，将某个时间点上的数据库状态保存到RDB文件中
* save命令会阻塞Redis服务器进程，直到RDB文件创建完毕，阻塞期间服务器进程不能处理任何命令；BGSAVE派生出一个子进程，负责创建RDB文件
   * bgsave执行时save和bgsave命令会被拒绝，防止产生竞争条件
   * bgrewriteaof和bgsave补鞥呢同时执行，并发出两个子进程，同时执行大量的磁盘写入，影响性能
* 如果开启了AOF持久化，优先使用AOF文件来还原数据库状态，只有AOF关闭才会使用RDB来还原
* 服务器在载入RDB是，一直阻塞

### 42.save设置
* 设置服务器状态redisServer结构的saveparams属性，saveparams是一个数组，每个元素都是一个saveparam结构
* saveparam结构都保存了一个save选项设置的保存条件：秒数和修改数，几个条件有一个满足就会执行保存（BGSAVE）指令
* 维持了dirty计数器和lastsave属性
   * dirty计数器记录距离上一次执行保存命令之后，对数据进行了多少次修改
   * lastsave记录上一次保存的时间，UNIX时间戳

### 43.RDB文件结构
* REDIS  db_version  databases（数据库内容）  EOF（结束标志）  check_sum（校验和）
* databases保存任意多个非空数据库
   * 每个非空数据库都可以保存为：selectdb（开始标志）  db_number（数据库号码）  key_value_pairs（所有的键值对数据）
   * key_value_pairs：不过期的由type、key、value组成，过期的由expiretime_ms（过期标志）、ms（过期时间，UNIX）、type、key、value组成

### 44.AOF持久化
* AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的
* 以Redis的命令请求协议格式保存的，纯文本格式
* AOF实现：命令追加、文件写入、文件同步
   * 命令追加：执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾
   * 写入与同步：写入时先写入缓冲区，提高了效率，但是会有数据安全的问题，提供了fsync和fdatasync函数，强制让操作系统将缓冲区的数据写入硬盘中
   * 配置appendfsync的值决定了AOF持久化功能的效率和安全性，always慢但安全；everysec足够快，相对安全；no很快，但不安全

### 45.Redis读取AOF文件并还原
* 创建一个不带网络连接的伪客户端来执行保存的写命令
* 从AOF文件中分析并读取写命令并在伪客户端执行



















